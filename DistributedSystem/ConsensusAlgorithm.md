# 分布式系统共识算法分析

## 😊分布式系统简介

### 分布式系统模型

想弄明白分布式共识问题，首先要了解分布式系统中的基础模型，我们在设计和思考分布式算法时，首先需要思考的一点就是算法运行的环境是什么，算法运行中需要处理什么样的问题，一般来说从以下三个方面来考虑：

*  分布式系统中节点会发生什么样的故障？最为常用的两种故障模型是 __故障-停止（Fail-stop)__ 和  __随机故障（Byzantine)__ ，在故障-停止模型中当进程发生故障后简单的停止运行，相对的，随机故障又称为拜占庭故障，意指发生故障的进程会像不忠的拜占庭将军一样，产生无法预料的响应结果。故障-停止是随机故障的一种特殊形式，因此，能够容忍随机故障的算法也能够容忍故障-停止。

*  分布式系统的网络传输时延特性是什么样的？  __在分布式系统中，节点间通过传递消息进行通信，按照消息在网络中传递时间是否有上限，可以将分布式系统分为同步模型（Synchronous model)和异步模型（Asynchronous model）， 在同步分布式系统中消息传递时间的上限是已知的，而在异步分布式系统中消息可能在任何时间送达__.因此在同步分布式系统中，由于消息传递时间的上限已知，则可以根据超时来检测进程故障（非拜占庭故障），大大简化了分布式算法的设计，但遗憾的是，大部分实际的分布式系统往往是异步的，比如互联网就是异步分布式系统，如果为异步分布式系统中设计分布式算法，必须意识到消息可能延迟任意长的时间到达。

*   分布式系统消息传递的可靠性如何？在分布式系统中传递的消息有可能出现丢失、乱序甚至重复送达的情况，算法是否需要容忍这些情况.网络分区就是一种常见的需要加以考虑的现象.


在整个设计和思考分布式算法的过程中，都要基于同样的系统模型来进行，并对分布式算法的正确性进行证明。通常来讲，一个正确的分布式算法需要满足两条性质：

* Safety：具备Safety性质的算法保证坏的事情绝对不会发生，例如对于满足Safety性质的分布式选主(Leader election)算法，绝对不会出现一个以上进程被选为Leader的情况。

* Liveness：具备Liveness性质的算法保证好的事情终将发生，即算法在有限的时间内可以结束。

综上，一个正确的分布式算法可以在指定的分布式系统模型中保证Safety和Liveness属性。


### 分布式共识（Consensus)

分布式共识问题，简单说，就是在一个或多个节点提议了一个值应当是什么后，使系统中所有节点对这个值达成一致意见。这样的协定问题在分布式系统中很常用，比如说选主（Leader election）问题中所有节点对Leader达成一致；原子组播（Atomic  broadcast）中节点对消息传递（delivery）顺序达成一致。对于这些问题有一些特定的算法，但是，分布式共识问题试图探讨这些问题的一个更一般的形式，如果能够解决分布式共识问题，则以上的问题都可以得以解决。

为了达到共识，每个节点都提出自己的提议（propose），最终通过共识算法，所有正确运行的节点决定（decide）相同的值。

共识算法的正确性要求是在运行中满足以下条件：

* 终止性（Liveness）：所有正确节点最后都能完成决定。

* 协定性（Safety）：所有正确节点决定相同的值。

* 完整性（Integrity）：如果正确的节点都提议同一个值，那么所有正确节点最终决定该值。


如果在一个不出现故障的系统中，很容易可以构造出一个符合要求的共识算法：每个节点都将自己的提议通过可靠组播（Reliable broadcast）发送给其他节点，当节点收到所有成员的提议后，取所有提议中出现最多的值作为最终决定即可。

而如果是在存在故障的异步系统中，共识问题是否有可用的解法呢?

著名的FLP不可能性证明告诉我们：** 没有任何算法可以在存在任何故障的异步系统中确保达到共识 ，正如之前说的，大部分实际的分布式系统都是异步的，FLP不可能性证明阻止了无数分布式系统设计者把时间浪费在寻找一个完美的异步系统共识算法上，而更应该去使用一个不那么完美却有实际意义的解法。


正如FLP不可能性证明所述，不存在算法可以“确保”达到共识，但我们可以设计出有较大概率可以达到共识的算法。绕过不可能性结论的办法是考虑部分同步系统，利用故障屏蔽、故障检测器或随机化手段避开异步系统模型，构造出可接受的共识算法。



### 共识与多副本状态机（Replicated state machines）

分布式系统中对共识问题的直接应用常常是在多副本状态机的场景中出现的。多副本状态机是指多台机器具有完全相同的状态，并且运行有完全相同的确定性状态机。通过使用这样的状态机，可以解决很多分布式系统中的容错问题，因为多副本状态机通常可以容忍⌊N／2⌋进程故障，且所有正常运行的副本都完全一致，所以，可以使用多副本状态机来实现需要避免单点故障的组件。虽然有很多不同的多副本状态机实现，但其基本实现模式是类似的：状态机的每个副本上都保存有完全相同的操作日志，保证所有副本状态机按照相同的顺序执行操作，这样由于状态机是确定性的，则一定会得到相同的状态。

共识算法的作用就是在这样的场景中保证所有副本状态机上的操作日志具有完全相同的顺序，具体来讲: 如果状态机的任何一个副本在本地状态机上执行了一个操作，则绝对不会有别的副本在操作序列相同位置执行一个不同的操作。

而在区块链中,共识算法需要解决的问题是在多个可能会出现随机故障的节点间维护其账本数据的一致性.


### 最终一致性以及比特币

#### 一致性、可用性,以及分区

* 一致性

  一个系统中所有节点就系统的当前状态达成一致
  
  * 可用性
  
  系统时可用的且正在处理请求
  
  * 分区容忍性
  
  分区容忍性是指分布式系统具备一种能力:在存在网络分区时仍可以正确的工作
  
  ##### CAP定理
  
  一个分布式系统不可能同时实现一致性,可用性以及分区容忍性.它可以满足其中任意两个要求,但是不能同时满足三个.
  
  假设一个银行系统存在分区,欧文准备在上海的一个ATM取1w,此时如果ATM允许欧文取出1w,则在北京,欧文银行账户的数据库余额不会及时更新,即不满足一致性.如果想要满足欧文账户余额的一致性,则上海ATM不能提供欧文取款服务,即不可用.
  
  * 最终一致性
     
     所有节点最终会就共享状态达成一致,但是可能在一个短的时间段内,共享状态在各个节点所存的状态可能不一致.在分区期间,不同节点可能执行不同的更新,而这些更新可能在语义上彼此矛盾,因此还需要一个 __冲突解决__ 机制来解决这些冲突,并使得这些节点最终在一个相同的状态上达成一致.
     
#### 比特币
  



# 😊共识算法

所谓区块链共识过程，是指如何将全网交易数据客观记录并且不可篡改的过程。目前, 比特币使用工作量证明PoW（Proof of Work），以太坊即将转换为权益证明PoS（Proof of Stake），柚子(EOS)使用授权权益证明DPoS（Delegated Proof of Stake). __以上这些算法可以称之为“经济学”的算法，所谓经济学的算法，是指让作弊成本可计算，且让作弊成本往往远大于作弊带来的收益，即作弊无利可图，通过这种思想构造一个用于节点之间博弈的算法，并使之趋向一个稳定的平衡。__

计算机领域的分布式一致性算法，例如Paxos、Raft，也称之为传统分布式一致性算法。他们之间的最大区别是：系统在拜占庭将军（Byzantine Generals Problem）情景下的可靠性，即拜占庭容错（PBFT算法支持拜占庭容错）。然而无论是Paxos还是Raft算法，理论上都可能会进入无法表决通过的死循环(尽管这个概率其实是非常非常低的)，但是他们都是满足safety的，只是放松了liveness的要求, PBFT也是这样。


## Paxos介绍

* Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。


* 在常见的分布式系统中，总会发生诸如机器宕机或网络异常（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。

* 简单的理解,在分布式系统中,即使出现网络异常以及节点出现机器死机的异常,利用Paxos算法可以保证每个节点整个系统中节点状态的一致性


### Paxos过程


        客户端(提案者)                                服务器(接收者)
        
        初始化---------------------------------------------------------
        
        c   --等待执行的命令                             Tmax --当前已发布的最大票号
        t=0 --当前尝试的票号
                                                     C --当前存储的命令
                                                     Tstore = 0 --用来存储命令C的票
       阶段1------------------------------------------------------------ 主要是尝试从服务器获取提案的票号,客户端有了有效的提案票号,其提案才可能被服务器接受
       
       1 t=t+1 
       2 向所有服务器发送消息,请求得到编号为t的票
        
                                                    3 if t > Tmax --服务器还没有发过票号t
                                                    4 Tmax = t --更新Tmax
                                                    5 回复:ok(Tstore,C) --回复给客户端当前已发布的最大票号和已存储的命令
                                                    6 end if
      
       阶段2-------------------------------------------------------------服务器会存储所有客户端的有效票号t,并返回其已经存储的提案(Tstore,C).客户端会使用票号t发起提案
           -------------------------------------------------------------每个客户端提案的内容c,主要由服务器端是否接受过提案C决定.如果存在服务器已经接受内容为C的提案,则
           -------------------------------------------------------------客户端只能使用票号t发布内容为C的提案
       
      
      7 if 过半数服务器回复ok then
      8 选择Tstore值最大的(Tstore,C)
      9 if Tstore > 0 then -- 如果Tstroe > 0 ,则说明至少有一个服务器接收到了票号为Tstore,命令为c的提案,此时客户端即为一个学习者,他的提案命令必须也是c
      10 c=C
      11 end if -- 如果Tstroe =< 0,此时客户端可以自己决定其提案命令c
      
      12   向这些回复了ok的服务器发送消息propose(t,c) --一个内容为(t,c)的提案
      13 end if
      
                                                     14 if t=Tmax then -- 票号如果有效,则服务器会存储该提案
                                                     15 C = c
                                                     16 Tstore = t
                                                     17 回复success
                                                     18 end if
                                                     
      阶段3---------------------------------------------------------------对提案内容的执行
      
      19 if 过半数服务器回复success then -- 如果一个提案被存储在过半数的服务器上,则该提案被选择
      20 向每个服务器发送消息execute(c)。--执行提案
      21 end if
      
       
### Paxos 算法的推理

如果想具体理解Paxos的具体工作过程,可以阅读和参考下面两篇文章:

* [Paxos算法原理与推导](http://www.cnblogs.com/linbingdong/p/6253479.html)
* [Paxo的经典论文](https://github.com/xianfeng92/Love-Ethereum/blob/master/book/paxos-simple.pdf)


## PBFT

该部分主要是对于存在拜占庭的系统,系统如果要达成共识,总节点数与拜占庭节点数之间需要满足的关系.


### 相关定义

* 拜占庭

  一个可能呈现任意行为的节点被称为拜占庭.任意行为意味着“所有能想象到的事情”,比如根本不发送任何消息,像不同的邻居发送不同且错误的消息,以及谎报自己的输入值.
  
  * 拜占庭协议
  
  在一个存在拜占庭节点的系统中达成共识被称为拜占庭协议.如果一个算法可以在存在f个拜占庭节点的情况下正常工作,则该算法为f可适用.
  
  * 共识
  
  系统中有n个节点,其中最多有f个节点可能崩溃,也就是说有n-f个节点是好的.节点i从一个输入值vi开始.所有节点要从全部输入值中最终选择一个值(决策值),并且满足下面的条件:
  
  __一致性__:所有好节点的决策值必须相同
  
  __可终止性__:所有好节点在有限的时间内终止决策过程
  
  __有效性__:选择出的决策值必须是其中一个节点的输入值
  
  
  对于存在拜占庭的系统,显然我们需要的是 __正确输入有效性__,即决策值必须是其中一个好节点的输入值. 然而实现 __正确输入有效性__并不那么容易.
  因为一个拜占庭节点可以遵守协议,但是谎报他的输入值,此时无法将其与一个好节点进行区分.
  
  __全部相同有效性__:如果所有好节点起始时具有相同的输入值v,则决策值必须也是v.

  
  ### 拜占庭协定(f=1)
  
  0:在一个分布式系统中所有节点都运行着同一份代码,该代码需要一个输入指令x.此时系统中所有节点需要在输入指令上达成共识,保证系统所有“好节点”都使用相同的输入指令.

 1: 节点u提议代码的输入指令值为x

          第一轮
        
        2:向所有其他节点发送tuple(u,x)
          
          节点u告诉其他节点,它提议输入指令为x
        
        3:从其他所有节点接受tuple(v,y)
        
         节点u接受其他节点的提议
         
        4:将所有接收到的消息tuple(v,y)存储在集合Su
        
         节点u汇总其他所有节点的提议
        
        
          第二轮
  
       5:向其他节点发送Su
       
         节点u将其所汇总的来自其他所有节点的提议Su发送给其他节点,注意Su中并不包含节点u的提议,其只是节点u收集到的所有提议!
         
       6:从其他节点接受Sv
      
       7:T = 所有出现在至少两个Sv中的tuple(v,y),包括自己的Su
       
       8:设tuple(v,y) 是T中y值最小的元组
       
       9:选择y为决策值
       
### 拜占庭协定(f=1)中如果节点数大于4,所有的好节点将得到同一个集合T

#### 假设一共有四个节点u v w x,其中w为拜占庭节点:

        节点u 收到的其他节点提议,即Su为 tuple(v,1)、 tuole(w,3), tuple(x,3);
        节点v 收到的其他节点提议,即Sv为 tuple(u,1)、 tuple(w,2), tuple(x,3);
        节点w 收到的其他节点提议,即Sw为 tuple(u,2)、 tuple(v,2), tuple(x,2);----w为拜占庭节点
        节点x 收到的其他节点提议,即Sx为 tuple(u,1)、 tuple(v,1), tuple(w,1);

        此时T为{tuple(v,1),tuple(x,3),tuple(u,1)}

        一个好节点将至少两次看到每一个正确的输入值.
        
        以节点u为例:
        
        第一次是对应该输入值的源节点得到即tuple(u,1)、tuple(v,1)、tuple(x,3),另一次是从第三个好节点那里得到,例如只有结合v和x才能得到tuple(u,1)、tuple(v,1)、tuple(x,3).
        因此所有正确的值都在集合T中.如果此时唯一的那个拜占庭节点将一个相同的值发送给至少两个好节点,所有好节点将至少看到该值两次,并且将它加入到集合T中.
        
        因此此时每个节点都会拥有一个相同的集合T,所有节点只需要选择集合T中最小的提议值即可达成共识.
        
        对于节点数大于4的情况,自然也会成立.
        
####  当只有三个节点u、v、w,其中w为拜占庭节点:
        
        节点u 收到其他节点的提议:tuple(v,1),tuple(w,2)
        节点v 收到其它节点的提议:tuple(u,2),tuple(w,3)
        节点w 收到其他节点的提议:tuple(v,0),tuple(u,3) -- w为拜占庭节点
        
        此时节点u收到的从节点v、w收到的关于v的提议值不同,此时是无法确定到底w和v哪个是拜占庭节点.同理v也无法确定u和w到底哪个是拜占庭节点.三个节点无法达成共识.
        
        => 若一个有n个节点的网络中存在f >=  n / 3个拜占庭节点,则该网络不能达成共识.
        
           我们可以选择极端的情况考虑,假设 f = 1,则此时n最大只能为3.这种情况上面已经举例证明了.f为1时,n最小应该为4,此时 1 < 4/3 .


## 😊区块链的共识算法


### POW


### POS

### DPOS






















