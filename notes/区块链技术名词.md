
## 分布式系统一致性

在分布式系统中，一致性(Consistency，早期也叫Agreement)是指对于系统中的多个服务节点，给定一系列操作，在协议(往往通过某种共识算法)保障下，试图使得它们对处理结果达成某种程度的一致。

## 最终一致性(Eventual Consistency)


即总会存在一个时刻(而不是立刻)，系统达到一致的状态，这对于大部分的 Web 系统来说已经足够了。这一类弱化的一致性，被笼统称为弱一致性(Weak Consistency)。


## 共识算法

实际上,要保障系统满足不同程度的一致性,往往需要通过共识算法来达成。共识算法解决的是对某个提案(Proposal),大家达成一致意见的过程。一般地，把故障(不响应)的情况称为“非拜占庭错误”，恶意响应的情况称为“拜占庭错误”(对应节点为拜占庭节点)。对于要能容忍拜占庭错误的情况，一般包括 PBFT系列、PoW 系列算法等。从概率角度，PBFT 系列算法是确定的，一旦达成共识就不可逆转。而PoW系列算法则是不确定的，随着时间推移，被推翻的概率越来越小。


## FLP不可能性原理

FLP不可能原理：在网络可靠，存在节点失效(即便只有一个)的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。FLP不可能原理实际上告诉人们，不要浪费时间去为异步分布式系统设计在任意场景下都能实现共识的算法。


## CAP原理

定义：分布式计算系统不可能同时确保一致性(Consistency)、可用性(Availablity)和分区容忍性(Partition)

1 一致性(Consistency)：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性

2 可用性(Availablity)：在有限时间内，任何非失败节点都能应答请求

3 分区容忍性(Partition)：网络可能发生分区，即节点之间的通信不可保障

比较直观地理解，当网络可能出现分区时候，系统是无法同时保证一致性和可用性的。要么节点收到请求后因为没有得到其他人的确认就不应答，要么节点只能应答非一致的结果。


## ACID 原则

即    Atomicity(原子性)、Consistency(一致性)、Isolation(隔离性)、Durability(持久性)。

ACID 原则描述了对分布式数据库的一致性需求，同时付出了可用性的代价：

1 Atomicity:每次操作是原子的，要么成功，要么不执行
3 Consistency:数据库的状态是一致的，无中间状态;
3 Isolation:各种操作彼此互相不影响
4 Durability:状态的改变是持久的，不会失效

一个与之相对的原则是    BASE(Basic    Availiability,Soft    state,Eventually    Consistency)，牺牲掉对一致性的约束(最终一致性)，来换取一定的可用性。



##  Paxos算法

Paxos 问题是指分布式的系统中存在故障(fault)，但不存在恶意(corrupt)节点场景(即可能消息丢失或重复，但无错误消息)下的共识达成(Consensus)问题。Paxos  能保证在超过1/2的正常节点存在时，系统能达成共识。在工程角度实现了一种最大化保障分布式系统一致性(存在极小的概率无法实现一致)的机制。



## 拜占庭问题与算法

拜占庭问题讨论的是允许存在少数节点作恶(消息可能被伪造)场景下的一致性达成问题。

对于拜占庭问题来说，假如节点总数为 N，叛变将军数为 F，则当 N >= 3F+1时，问题才有解，即 Byzantine Fault Tolerant (BFT) 算法。能确保达成一致的拜占庭系统节点数至少为 4，允许出现 1 个坏的节点。

比特币的区块链网络在设计时提出了创新的 PoW（Proof of Work） 算法思路。一个是限制一段时间内整个网络中出现提案的个数（增加提案成本），另外一个是放宽对最终一致性确认的需求，约定好大家都确认并沿着已知最长的链进行拓宽。系统的最终确认是概率意义上的存在。这样，即便有人试图恶意破坏，也会付出很大的经济代价（付出超过系统一半的算力）。


## Hash算法

Hash(哈希或散列)算法是信息技术领域极为基础和重要的技术。它能将任意长度的二进制值(明文)映射为较短的固定长度的二进制值(Hash值)，并且不同的明文很难映射为相同的 Hash值。一般的，Hash 算法都是算力敏感型，意味着计算资源是瓶颈，主频越高的 CPU 进行 Hash 的速度也越快。

一个优秀的hash算法，将能实现:

正向快速：给定明文和hash算法，在有限时间和有限资源内能计算出hash 值。
逆向困难：给定(若干) hash 值，在有限时间内很难(基本不可能)逆推出明文。
输入敏感：原始输入信息修改一点信息，产生的hash值看起来应该都有很大不同。
冲突避免：很难找到两段内容不同的明文，使得它们的hash值一致(发生冲突)。

目前，一般认为MD5 和SHA1已经不够安全，推荐至少使用SHA2-256算法。


## 数字摘要

顾名思义，数字摘要是对数字内容进行Hash运算，获取唯一的摘要值来指代原始数字内容。数字摘要是解决确保内容没被篡改过的问题(利用Hash函数的抗碰撞性特点)。


## 加解密算法

现代加密算法的典型组件包括:加解密算法、加密密钥、解密密钥。其中，加解密算法自身是固定不变的，一般是公开可见的；密钥则往往每次不同，并且需要保护起来，一般来说，对同一种算法，密钥长度越长，则加密强度越大。


## 数字签名

类似在纸质合同上签名确认合同内容，数字签名用于证实某数字内容的完整性(integrity)和来源(或不可抵赖,non-repudiation)。

一个典型的场景是,A要发给B 一个文件(一份信息),B如何获知所得到的文件即为A发出的原始版本. A先对文件进行摘要，然后用自己的私钥进行加密,将文件和加密串都发给B。B 收到后文件和加密串，用A 的公钥来解密加密串，得到原始的数字摘要，跟对文件进行摘要后的结果进行比对。如果一致，说明该文件确实是 A 发过来的，并且文件内容没有被修改过。



## 数字证书

数字证书用来证明某个公钥是谁的，并且内容是正确的。对于非对称加密算法和数字签名来说，很重要的一点就是公钥的分发。一旦公钥被人替换(典型的如中间人攻击)，则整个安全体系将被破坏掉。

怎么确保一个公钥确实是某个人的原始公钥？这就需要数字证书机制。

顾名思义，数字证书就是像一个证书一样，证明信息和合法性。由证书认证机构(Certification    Authority，CA)来签发。类似的，CA    的数字签名合法不合法也是通过 CA    的证书来证明的。主流操作系统和浏览器里面会提前预置一些    CA    的证书(承认这些是合法的证书)，然后所有基于他们认证的签名都会自然被认为合法。



## 零知识证明

证明者在不向验证者提供任何有用的信息的前提下，使验证者相信某个论断是正确的。例如，A向B证明自己有一个物品，但B无法拿到这个物品，无法用A的证明去向别人证明自己也拥有这个物品。



## 挖矿

了解比特币，最应该知道的一个概念就是“挖矿”，挖矿是参与维护比特币网络的节点，通过协助生成新区块来获取一定量新增的比特币。当用户发布交易后，需要有人将交易进行确认，写到区块链中,形成新的区块。在一个互相不信任的系统中，该由谁来完成这件事情呢？比特币网络采用了“挖矿”的方式来解决这个问题。
目前，每 10 分钟左右生成一个不超过1MB大小的区块(记录了这 10 分钟内发生的验证过的交易内容)，串联到最长的链尾部，每个区块的成功提交者可以得到系统 12.5个比特币的奖励(一定区块数后才能使用)，以及用户附加到交易上的支付服务费用。区块链的技术和安全的过程使得陌生人之间在没有被信任的第三方时产生信任。

基本上拿到 1/3 的计算力，比特币网络就存在被破坏的风险了；拿到 1/2，概率上就掌控整个网络了。但是这个将需要付出巨大的计算成本。那么有没有办法防护呢？除了尽量避免计算力放到同一个组织手里，没太好的办法，这是目前    PoW(Proof of Work)的协议规定的。有人提出用所谓的    PoS(Proof    of    Stake)和DPoS，即大节点作为多个节点代理人的模式来节约计算力。


## 共识机制

比特币网络对共识进行了一系列的放宽，同时对参与共识进行了一系列的限制。首先是不实现最终共识，理论上现有达成的任何结果都可能被推翻，只是被推翻的可能性随着时间而指数级的下降，要付出的代价迅速上升。此外，达成共识的时间比较长，而且是按照块来进行阶段性的确认，提高网络可用性。此外，通过进行 PoW限制合法提案的个数，提高网络的稳定性。

目前，Proof  of 系列中比较出名的一致性协议包括  PoW  和  PoS，都是通过经济惩罚来限制恶意参与。

## PoS

典型的过程是通过保证金(代币、资产、名声等具备价值属性的物品即可)来对赌一个合法的块成为新的区块，收益为抵押资本的利息和交易服务费。PoS是试图解决在PoW中大量资源被浪费的缺点。恶意参与者将存在保证金被罚没的风险，即损失经济利益。PoS也有一些改进的算法，包括授权股权证明机制(DPOS)，即股东们投票选出一个董事会，董事会中成员才有权进行代理记账。


## 闪电网络

闪电网络的主要思路十分简单    --    将大量交易放到比特币区块链之外进行。比特币的区块链机制自身提供了很好的可信保障，但是很慢；另一方面考虑，对于大量的小额交易来说，是否真实需要这么高的可信性？闪电网络通过智能合约来完善链下的交易渠道。

核心的概念主要有两个：RSMC(Recoverable    Sequence    Maturity    Contract)和HTLC(Hashed    Timelock    Contract)


## RSMC

Recoverable    Sequence    Maturity    Contract，中文可以翻译为“可撤销的顺序成熟度合同”。这个词很绕，就是类似准备金机制。我们先假定交易双方之间存在一个“微支付通道”(资金池)。双方都预存一部分资金到“微支付通道”里，之后的交易，就对交易后的资金分配方案共同进行确认，同时签字作废旧的版本。当需要提现时，将最终交易结果写到区块链网络中，被最终确认。可以看到，只有在提现时候才需要通过区块链。


## HTLC

微支付通道是通过    Hashed    Timelock    Contract    来实现的，中文意思是“哈希的带时钟的合约”。

RSMC 保障了两个人之间的直接交易可以在链下完成，HTLC    保障了任意两个人之间的转账都可以通过一条“支付”通道来完成。整合这两种机制,就可以实现任意两个人之间的交易都可以在链下完成了。在整个交易中,智能合约起到了中介的重要角色,而区块链则确保最终的交易结果被确认。



## 交易签名和验证


### 付款方--签名：

*  A 生成一个账单，其内容主要包括：
资金来源T1，即代表A付款的1btc的来源。
付款方A的钱包地址
收款方B的钱包地址
收款方的公钥 P
T1和P的hash值Y-----Y即为T1和P的摘要
A的私钥对Y加密得到A的签名S


### 收款方--验证：

1 得到付款人A的公钥 P，这是用来解密A的签名S的钥匙。P可以从T1中找到。
2 收款人B解密 T1 上 A 的签名S，得到 A 加密前的内容，是一个整数 X
3 收款人B把T1 交易单数据与B的公钥联合起来, 取 hash 值Y
4 检验X是否等于Y。如果等于，那么说明 T2 交易单有效。一定是 A 发出的，且资金来源A 无法抵赖。


## 禁止重复支付

禁止重复支付，是比特币技术要解决的核心问题。它的核心，就是在 P2P 网络体系下，创建一套全世界统一且有唯一时序的交易记录.

比特币世界里，每本账簿记录 10分钟的交易记录，其是按照时间顺序，依次在账簿中排列。肯定不能用一段字符串标记时间，来判断账簿的前后关系 。这种明文在没有中央节点服务器的体系下是行不通的。因为用户机器上的时间不可能都严格一致。

决定账簿前后关系的机制，采用了 __时间戳机制(TimeStamps)__，这个标记使用一个账簿数据的hash。__如果我们使得每个账簿的内容，和前一个账簿内容相关，并且可以验证这一点。那么就可以说明账簿的前后关系。因为如果没有前一个账簿的内容去生成后面的账簿，后一个账簿内容一定是非法的__。

## 检测重复支付

当由节点创建出来的临时账簿在全网广播后，每个收到账簿的节点都要判断这个数据块中的交易单都是合法的。并且,根据已经创建的世界账簿链中交易单，逐一查找，以判断这个临时账簿内所有的交易单，在世界中已经发生的所有交易中从来没有出现过。这点很重要，判定是否有重复支付，就在这个环节完成。

当所有节点检测一个临时账簿没有重复支出，交易单都合法后，节点会把收到的这个账簿，临时挂接到本地备份的世界账簿链的最后。


##  sha256散列算法

sha256 散列的含义:可以理解为 sha256 是一个函数。任何一串数据,送入这个函数,都会得到一个整数。这个整数大小范围在 0 到 2^256 次方。也就是 256bit 长度的整数。相同的数据送入此函数,会得到相同的结果。数据不同,就会得到不同的结果。


## 如何判定一个制造账簿的用户是诚实的

### Hash工作量证明机制

如果希望判定一个人提供的的信息是本着正常使用，具备一定价值的。那么我们倾向认为提供这个信息的人，愿意为此付出一定工作量来证明他的诚实。假如有一种机制，能够容易的证明提供信息的人为此付出了一定工作量，那么此信息是可以接受，并被认为合理的。

一个 P2P 用户节点如果要试图创建一个被全网认可的新账簿(挖矿节点)，要花很大力气做一些毫无意义的运算(挖矿)。运算结果可以被所有人容易的证明他确实做了这些工作。

游戏的规则是:

1  得到这个世界中已经创建好的账簿链中最后一个账簿 ，用这个账簿内容做数据，计算一个 hash 值
2 不断接收这个世界被广播出来，且没有被放入账簿链的交易单。检验这些交易单(根据交易单链信息和支付款项等信息)，剔除掉不合理的(比如账户余额不足的支付)。
3 猜一个幸运随机数 n(比如从 0 一直到 999999.... )
4 把 1-3 步骤得到的数据都组织起来成为一个数据 buffer，送入 sha256，得到一个 256bit的散列值 x
5 检查 x 这个整数，前面若干 bit(比如 96bit)是否都是 0?如果是，这个 x 符合“工作量证明难度”么? 如果符合，那么“工作量证明”游戏结束!
6 如果不是，从步骤 2 开始不断重复。假如这个时候收到了一个其他节点发来的新的账簿数据块。还没有猜出满足要求的随机数，需要重新开始游戏。

这种重复性的计算往往要重复上亿次，才会得到一个幸运随机数。

游戏如果及时结束，我们就得到了一个幸运随机数 n , 以及一组未放入世界统一账簿集里的交易单! 这个随机数 n 代表了我为了证明我的诚实做出的努力。到此为止,一个“工作量证明”结束。 我证明了我是个诚实的用户。


## 账簿链分支判断，最终创建账簿

全网到处广播着被新创建出来的临时账簿。有时候一个节点会先后收到连接在同一个链尾部的多个新创建临时账簿。这时候，一个节点在本地会把自己维护的本地账簿链建立分支。比如一个节点先后收到 2个临时账簿块。它们两个同位于世界账簿链的最后一个账簿链表的后面。之后此节点继续在先收到的账簿分支后面进行工作量证明的工作------利用先收到的临时账簿,进行创建下一个账簿的工作。

每个节点收到新建临时账簿的时间不同，在本地建立的账簿链分支也会不同。

当节点收到最长的工作链账簿时，会抛弃掉比较短的分支。转为在最长的链条上工作。较短分支里面的交易单会被拿出来检查，如果存在没有放入现存账簿的交易单，会继续用作新工作量证明的素材。

临时账簿被不断创建，广播。当全网节点全部确认一个共同的难度总和最大的账簿链条，并开始在这个链条之后开始工作量证明，这个账簿链中的账簿，就被最终确认为世界统一账簿链。里面记录的交易单，就作为世界统一交易，被永久封存。


## 交易确认过程

一个交易单，要想被最终确认。需要首先被放入一个新成功创建的账簿。然后，再经历几个(一般是 5 个)新账簿的创建后，这个交易单才被最终确认安全通过。表明支付成功。

因为往往世界账簿链被增加 6 个之后，账簿链被修改和作弊的可能性已经几乎降为 0.

一旦一个交易单被所有节点确认通过，再想修改和取消，几乎是不可能的。这保证了比特币体系的不可逆转性和不可更改性。



1） P2P 所有网络用户监督交易，保存全局统一交易记录备份 

2 ) 时间戳保证交易顺序，无法修改账簿链

3） sha256 保证创建合法账簿极难，检验账簿合法性极其容易

4 ) 非对称加密保证无法伪造别人支付给作弊者的交易单

5 ) 工作量证明机制，保证数量占优的诚实节点产生的统一交易记录内容与次序真实


## 钱包

钱包就是存储和使用数字货币的工具，用来存储币种，或者“交易”。冷钱包就是不连网的钱包，也叫离线钱包。热钱包就是保持联网上线的钱包，也就是在线钱包。冷钱包不联网会比热钱包更安全。
















































